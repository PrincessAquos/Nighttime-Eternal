# Informal Disclaimer
Nighttime Eternal is a fan game inspired by the television show My Little Pony: Friendship is Magic. My Little Pony, My Little Pony: Friendship is Magic, its trademarks, characters, worlds, stories, and other components are all property of Hasbro and related entities. This project is not made in affiliation with Hasbro, nor is it made in any official affiliation with said property. This is a passion project meant purely to celebrate the show and the fan community surrounding it. It will not and should not be sold, unless some form of authorization from all significant copyright holders leads to me removing this disclaimer. That is something I sincerely do not expect to ever happen, but occasionally seemingly impossible things do happen. I'm not holding my breath. 

I do maintain ownership of the code I have written, and any audiovisual elements within that do not bear any relation to the My Little Pony franchise, the fan community, or any other established intellectual property. This project contains derivative audiovisual elements that fall under Hasbro's intellectual property, and may eventually contain derivative audiovisual elements of original works of creators within the show's fan community. Please support Hasbro, the official My Little Pony brand, Lauren Faust, any members of the show's staff, and all the incredible creators whose work was featured in this project. They all deserve a great deal of praise for this absolutely incredible generation of My Little Pony.

# "Playing" Nighttime Eternal in its Current State
Nighttime Eternal is a Strategy Role Playing Game set in the universe of My Little Pony: Friendship is Magic. It originally drew all its gameplay inspiration from Fire Emblem before I came up with my own variations on Strategy RPG gameplay.

Currently there is no compiled build of the game. Running the game project in Game Maker Studio will present you with a simple test room for character movement. The test room contains some characters and a small stretch of wall tiles, to see how the range of movement behaves around a simple wall. 

The in-game cursor snaps to a grid, and it follows the mouse. Moving the cursor over a character gives a preview of their range of movement, and lists their statistics on the Heads-Up Display on the right.

A character's range of movement is determined by their Stamina. All of the traversible tiles in the test room cost 10 stamina to traverse, so a character with 80 stamina can move up to 8 tiles.

Clicking the left mouse button while the cursor is highlighting a character opens a dropdown menu with the functions "Move", "Attack", "Check Stats", and "Cancel". Currently, only the "Move" and "Cancel" buttons work. The others simply perform the "Cancel" function, closing the menu. If you click "Move", the range of movement becomes more opaque, and moving the cursor around will begin drawing a path of travel for the character.

While drawing a path, moving the cursor to a different tile within the movement range will add it to the path. If you mouse back over a tile that's already in the path, any tiles after it will be removed from the path. If you move the cursor to a valid tile, but the path you've drawn would cost more stamina than is available, then your path will be scrapped, and a most efficient path to that tile will be drawn automatically. If you manage to move the cursor between tiles diagonally, or move the cursor from one valid move node to a non-adjacent one, your path will be scrapped and replaced with a most efficient path to the new tile instead.

You can move the view around using WASD, and zoom in and out using the scroll wheel. The zoom functions relative to the location of your cursor, so that wherever your mouse is pointing before the zoom, it will still be targeting the same pixel in the level after the zoom.

# Implementation Details
Directions are indicated using a numerical system. "ORIGIN", which acts as a sort of non-direction, corresponds to 0. "LEFT" corresponds to -1 and "RIGHT" corresponds to 1. "UP corresponds to -2 and "DOWN" corresponds to 2. The directions taking on these values represents their relationship to Game Maker's coordinate system; moving downward on the screen is an increase in the y coordinate, and moving rightward on the screen is an increase in the x coordinate, thus those use positive numbers. I also use these directional values to do some neat things with drawing paths.

The range of movement, called a "move map" in the code, is calculated using a priority queue and breadth first search, abbreviated as PQBFS. By using a priority queue and searching breadth first, I can avoid excessive retreading of the same areas looking for more efficient paths to each tile. This solution also uses data recursion instead of function recursion, which gives me more control over the memory being used by the process. Breadth first is the best option here because it's very non-directed pathing; I'm not trying to path to a specific point, I'm just trying explore all of the character's available space so that I can display options to the player.

Every loop, the move map node with the highest remaining stamina is popped off of the queue. For the first loop, the character's position is used (though this position doesn't get a move node; it is instead the location of the move map object) along with the character's current stamina and a source direction of "ORIGIN" or 0. It attempts to add the tiles in the 4 cardinal directions to the queue, but only for every direction other than the source direction of the search (that is, the direction from which the search reached this tile) to avoid unnecessarily looking backward. For each direction, it looks for a preexisting node. If it doesn't find one, it makes sure that the remaining stamina is non-negative, creates a new node, and adds it to the queue. If it does find one, it checks if the remaining stamina of this search is greater than the stamina stored in the node. If it is, the optimal direction and remaining stamina of the node are updated, and its priority in the queue is updated to reflect that change. If it had already been removed from the queue, it will be added back to the queue.

A node in this move map stores the maximum stamina you can reach the tile with, as well as the direction that the most efficient path came from. During move map creation, if it's trying to queue a tile that already has a corresponding node, the remaining stamina of the current search will be compared to the max stamina value of the node, and, if the current search is more efficient, the tile will have its optimal direction, max stamina, and priority in queue updated. If the node's been removed from the queue already, then, instead of updating its priority, it will be queued again.

Paths are implemented like linked lists, with each path tile linking to the next and previous. In most situations they behave like a stack, but sometimes they behave like a queue, or need more involved functions. As you move your mouse to new tiles, they get added to the top of the path. If you move your cursor to a new tile, and said tile is already in the path, then all tiles after it are popped off, leaving you with the path you'd drawn up to that tile.

To construct a most efficient path, the program works backwards from the destination tile, using the direction marked within each node of the move map as being the most efficent until the source character is reached, resulting in a most-efficient path to that tile.

The graphics for the paths are determined by the script move_path_tile_update.gml and the directions of each path tile. The first step in determining a path tile's sprite is to check if there is a path node after the one being updated. If there isn't one, the tile should display an arrow pointing in its direction. But if there does exist a node after it, then I calculate which path segment to draw. My calculation involves subtracting the current tile's direction value from that of the tile after it, and matching that value to the proper path segment image. This has some convenient results when it comes to drawing turns in the path. For instance, a path that goes left then up will have the result 1 (-1 - -2) and if a path goes down then right, the result will also be 1 (2 - 1). Such a relationship is significant because the corners that yield identical numbers from this calculation actually do share the same graphics. Additionally, if the subtraction yields a 0, that means there was no turn (it was the same direction twice), so you can just look at the absolute value of the current tile's direction, using the horizontal or vertical straight segment for a value of 1 or 2, respectively.

The reason this calculation can describe the corner graphics is because, like with drawing a corner in these paths, order matters for subtraction. For instance, `right->down` is distinct from `down->right`. Likewise, the numerical representations of opposite directions are themselves numerically opposite. These shared properties make it extremely easy to map this problem onto subtraction. This behavior becomes pretty obvious when it's mapped out:
```
For any x and any y:
  x  -   y  = (-y) - (-x)   |   (right->down) = (up->left)
(-x) -   y  = (-y) -   x    |   (left->down)  = (up->right)
  x  - (-y) =   y  - (-x)   |   (right->up)   = (down->left)
(-x) - (-y) =   y  -   x    |   (left->up)    = (down->right)
```
I find this manner of solution to be quite fascinating, and I can't say I remember exactly when I came up with it. I'm not even sure if it's more efficient, or if such an efficiency boost would even matter, given the fact that this isn't going to be need to be run enough times a second for it to be noticeable. Nonetheless, the solution feels elegant to me, and it was a very fun puzzle to solve.

# The Engine & Its Effect on Code Organization
Game Maker Studio, for the developer, is only partially object oriented. There are structures in Game Maker that are called "Objects," and they can contain code. However, the developer is mostly restricted to a set number of functions called "Events," which are called when certain triggers occur, and can be defined/redefined using the object editor. For instance, the "Step" event is called for that object once every 30th of a second, or whatever you've set the game speed to. One can try to use "User Defined Events" to simulate having class methods, but you can only have a limited number of them per object, and they cannot be named; they can only be referenced by number. This can greatly limit options for organizing code that a developer may want to pair with a certain object. The way it's designed generally matches Game Maker's simple, approachable environment for beginners and non-coders, but it can be a struggle to work around as a more advanced user with broader coding experience.

The closest that Game Maker gets to having user-defined methods and functions are "Scripts". Essentially, every callable function has to be its own script file. They can be organized into folders within the editor, but they won't occupy said folder path in the file system. As such, only the name of the script file is used to invoke a script. Scripts can also take up to 10 arguments, but arguments are passed into an array called "argument", and must be manually assigned to named variables if you want your code to be readable.
